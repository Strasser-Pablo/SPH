#include <algorithm>

Boundaries<2>::Boundaries(const Key<2> & k1, const list<Key<2 > > & key_list):m_all(false)
{
AddBoundaries(k1,key_list);
}


Boundaries<3>::Boundaries(const Key<3> & k1, const list<Key<3 > > & key_list):m_all(false)
{
	AddBoundaries(k1,key_list);
}

void Boundaries<2>::AddBoundaries(const Key<2> & k1, const list<Key<2 > > & key_list)
{
	clear();
for(list<Key<2> >::const_iterator it=key_list.begin(); it!=key_list.end(); ++it)
		{
			int x=it->GetX()- k1.GetX();
			int y=it->GetY()- k1.GetY();
			if(abs(x)<1&&abs(y)<1)
				{
					if(x*y!=0)
						{
							push_back(Boundary<2>(x,y));
						}
				}
		}
	Update();	
}

void Boundaries<3>::AddBoundaries(const Key<3> & k1, const list<Key<3 > > & key_list)
{
	clear();
	for(list<Key<3> >::const_iterator it=key_list.begin(); it!=key_list.end(); ++it)
		{
			int x=it->GetX()- k1.GetX();
			int y=it->GetY()- k1.GetY();
			int z=it->GetZ()- k1.GetZ();
			if(abs(x)<1&&abs(y)<1&&abs(z)<1)
				{
					if(x*y*z!=0)
						{
							push_back(Boundary<3>(x,y,z));
						}
				}
		}
	Update();
}

Boundaries<2>::Boundaries():m_all(false)
{
}

Boundaries<3>::Boundaries():m_all(false)
{
}

void Boundaries<2>::Update()
{
	if(size()==8)
		{
			m_all=true;
			clear();
		}
}

void Boundaries<3>::Update()
{
	if(size()==26)
		{
			m_all=true;
			clear();
		}
}

bool Boundaries<2>::HasBoundary()
{
	return m_all;
}

bool Boundaries<3>::HasBoundary()
{
	return m_all;
}

void Boundaries<2>::AddBoundary(const Key<2>& k1,const Key<2>& k2)
{
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	if(abs(x)>1||abs(y)>1){
		return;
	}
	if(x*y==0){
		return;
	}
	Boundary<2> B(x,y);
	if(find(begin(),end(),B)==end()){
		push_back(B);
	}
}
void Boundaries<3>::AddBoundary(const Key<3>& k1,const Key<3>& k2)
{
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	int z=k2.GetZ()-k1.GetZ();
	if(abs(x)>1||abs(y)>1||abs(z)>1){
		return;
	}
	if(x*y*z==0){
		return;
	}
	Boundary<3> B(x,y,z);
	if(find(begin(),end(),B)==end()){
		push_back(B);
	}
}

void Boundaries<3>::RemoveBoundary(const Key<3>& k1,const Key<3>& k2)
{
	Update();
	if(m_all){
	list<Key<3> > l=k1.GetNeighbour();
		AddBoundaries(k1,l);
		m_all=false;
	}
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	int z=k2.GetZ()-k1.GetZ();
	Boundary<3> B(x,y,z);
	remove(begin(),end(),B);
	Update();
}

void Boundaries<2>::RemoveBoundary(const Key<2>& k1,const Key<2>& k2)
{
	Update();
	if(m_all){
	list<Key<2> > l=k1.GetNeighbour();
		AddBoundaries(k1,l);
		m_all=false;
	}
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	Boundary<2> B(x,y);
	remove(begin(),end(),B);
	Update();
}

void Boundaries<2>::Dump()const{
	cout<<"["<<endl;
	for(Boundaries<2>::const_iterator it=begin();it!=end();++it){
		it->Dump();
	}
cout<<"["<<endl;
}

void Boundaries<3>::Dump()const{
	cout<<"["<<endl;
	for(Boundaries<3>::const_iterator it=begin();it!=end();++it){
		it->Dump();
	}
	cout<<"]"<<endl;
}