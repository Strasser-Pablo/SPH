#include <algorithm>

Boundaries<2>::Boundaries(const Key<2> & k1, const list<Key<2 > > & key_list):m_all(false)
{
AddBoundaries(k1,key_list);
}


Boundaries<3>::Boundaries(const Key<3> & k1, const list<Key<3 > > & key_list):m_all(false)
{
	AddBoundaries(k1,key_list);
}

void Boundaries<2>::AddBoundaries(const Key<2> & k1, const list<Key<2 > > & key_list)
{
	clear();
for(list<Key<2> >::const_iterator it=key_list.begin(); it!=key_list.end(); ++it)
		{
			int x=it->GetX()- k1.GetX();
			int y=it->GetY()- k1.GetY();
			if(abs(x)<=1&&abs(y)<=1&&(x!=0||y!=0))
				{
							push_back(Boundary<2>(x,y));
				}
		}
	Update();	
}

void Boundaries<3>::AddBoundaries(const Key<3> & k1, const list<Key<3 > > & key_list)
{
	clear();
	for(list<Key<3> >::const_iterator it=key_list.begin(); it!=key_list.end(); ++it)
		{
			int x=it->GetX()- k1.GetX();
			int y=it->GetY()- k1.GetY();
			int z=it->GetZ()- k1.GetZ();
			if(abs(x)<=1&&abs(y)<=1&&abs(z)<=1&&(x!=0||y!=0||z!=0))
				{
							push_back(Boundary<3>(x,y,z));
				}
		}
	Update();
}

Boundaries<2>::Boundaries():m_all(false)
{
}

Boundaries<3>::Boundaries():m_all(false)
{
}

void Boundaries<2>::Update()
{
	if(size()==8)
		{
			m_all=true;
			clear();
		}
}

void Boundaries<3>::Update()
{
	if(size()==26)
		{
			m_all=true;
			clear();
		}
}

bool Boundaries<2>::HasBoundary() const
{
	return !m_all;
}

bool Boundaries<3>::HasBoundary() const
{
	return !m_all;
}

void Boundaries<2>::AddBoundary(const Key<2>& k1,const Key<2>& k2)
{
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	if(abs(x)>1||abs(y)>1){
		return;
	}
	if(x==0&&y==0){
		return;
	}
	Boundary<2> B(x,y);
	if(find(begin(),end(),B)==end()){
		push_back(B);
	}
}
void Boundaries<3>::AddBoundary(const Key<3>& k1,const Key<3>& k2)
{
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	int z=k2.GetZ()-k1.GetZ();
	if(abs(x)>1||abs(y)>1||abs(z)>1){
		return;
	}
	if(x==0&&y==0&&z==0){
		return;
	}
	Boundary<3> B(x,y,z);
	if(find(begin(),end(),B)==end()){
		push_back(B);
	}
}

void Boundaries<3>::RemoveBoundary(const Key<3>& k1,const Key<3>& k2)
{
	Update();
	if(m_all){
	list<Key<3> > l=k1.GetNeighbour();
		AddBoundaries(k1,l);
		m_all=false;
	}
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	int z=k2.GetZ()-k1.GetZ();
	Boundary<3> B(x,y,z);
	remove(begin(),end(),B);
	Update();
}

void Boundaries<2>::RemoveBoundary(const Key<2>& k1,const Key<2>& k2)
{
	Update();
	if(m_all){
	list<Key<2> > l=k1.GetNeighbour();
		AddBoundaries(k1,l);
		m_all=false;
	}
	int x=k2.GetX()-k1.GetX();
	int y=k2.GetY()-k1.GetY();
	Boundary<2> B(x,y);
	remove(begin(),end(),B);
	Update();
}

void Boundaries<2>::Dump()const{
	cout<<"["<<endl;
	for(Boundaries<2>::const_iterator it=begin();it!=end();++it){
		it->Dump();
	}
cout<<"["<<endl;
}

void Boundaries<3>::Dump()const{
	cout<<"["<<endl;
	for(Boundaries<3>::const_iterator it=begin();it!=end();++it){
		it->Dump();
	}
	cout<<"]"<<endl;
}

void Boundaries<2>::GetExteriorDirection(vector< physvector<2> >& v)const{
	bool b[4];
	int ipos[4];
	for(int i=0;i<4;i++){
		b[i]=false;
	}
	for(Boundaries<2>::const_iterator it=begin();it!=end();++it){
		int itemp=it->GetMirorID();
		if(!b[itemp]){
	b[itemp]=true;
	ipos[itemp]=int(distance(begin(),it));
	}
	else{
		b[itemp]=false;
	}
}


v.clear();
bool b2[4];
for(int i=0;i<4;i++){
		b2[i]=false;
	}
if(!empty()){
for(int i=0;i<4;i++){
		if(b[i]){
			Boundary<2> temp=*(begin()+ipos[i]);
			int xtemp,ytemp;
			temp.Get(xtemp,ytemp);
			if(xtemp<0){
				b2[0]=true;
			}else if(xtemp>0){
				b2[1]=true;
			}
			if(ytemp<0){
				b2[2]=true;
			}else if(ytemp>0){
				b2[3]=true;
			}
		}

	}
	
	if(b2[0]){
		v.push_back(physvector<2>(1.0,0.0));
	}
	if(b2[1]){
		v.push_back(physvector<2>(-1.0,0.0));
	}
	if(b2[2]){
		v.push_back(physvector<2>(0.0,1.0));
	}
	if(b2[3]){
		v.push_back(physvector<2>(0.0,-1.0));
	}
}else{

		v.push_back(physvector<2>(1.0,0.0));
		v.push_back(physvector<2>(-1.0,0.0));
		v.push_back(physvector<2>(0.0,1.0));
		v.push_back(physvector<2>(0.0,-1.0));
	}

}


void Boundaries<3>::GetExteriorDirection(vector< physvector<3> >& v)const{
	bool b[14];
	int ipos[14];
	for(int i=0;i<14;i++){
		b[i]=false;
	}
	
	for(Boundaries<3>::const_iterator it=begin();it!=end();++it){
		int itemp=it->GetMirorID();
		if(!b[itemp]){
	b[itemp]=true;
	ipos[itemp]=int(distance(begin(),it));
	}
	else{
		b[itemp]=false;
	}
}
	
v.clear();
bool b2[6];
for(int i=0;i<6;i++){
		b2[i]=false;
	}
if(!empty()){
for(int i=0;i<14;i++){
		if(b[i]){
			Boundary<3> temp=*(begin()+ipos[i]);
			int xtemp,ytemp,ztemp;
			temp.Get(xtemp,ytemp,ztemp);
			if(xtemp<0){
				b2[0]=true;
			}else if(xtemp>0){
				b2[1]=true;
			}
			if(ytemp<0){
				b2[2]=true;
			}else if(ytemp>0){
				b2[3]=true;
			}
			if(ztemp<0){
				b2[4]=true;
			}else if(ztemp>0){
				b2[5]=true;
			}
		}
	}
	
	if(b2[0]){
		v.push_back(physvector<3>(1.0,0.0,0.0));
	}
	if(b2[1]){
		v.push_back(physvector<3>(-1.0,0.0,0.0));
	}
	if(b2[2]){
		v.push_back(physvector<3>(0.0,1.0,0.0));
	}
	if(b2[3]){
		v.push_back(physvector<3>(0.0,-1.0,0.0));
	}
	if(b2[4]){
		v.push_back(physvector<3>(0.0,0.0,1.0));
	}
	if(b2[5]){
		v.push_back(physvector<3>(0.0,0.0,-1.0));
	}
}else{
		v.clear();
		v.push_back(physvector<3>(1.0,0.0,0.0));
		v.push_back(physvector<3>(-1.0,0.0,0.0));
		v.push_back(physvector<3>(0.0,1.0,0.0));
		v.push_back(physvector<3>(0.0,-1.0,0.0));
		v.push_back(physvector<3>(0.0,0.0,1.0));
		v.push_back(physvector<3>(0.0,-0.0,-1.0));
	}
	
}