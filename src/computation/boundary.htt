
Boundary<3>::Boundary(int x,int y,int z):m_x(x),m_y(y),m_z(z)
{

}


Boundary<2>::Boundary(int x,int y):m_x(x),m_y(y)
{

}

bool Boundary<2>::operator==(const Boundary &B) const{
 return m_x==B.m_x&&m_y==B.m_y;
}

bool Boundary<3>::operator==(const Boundary &B) const{
 return m_x==B.m_x&&m_y==B.m_y;	
}

void Boundary<2>::Dump()const{
	cout<<m_x<<" "<<m_y<<endl;
}

void Boundary<3>::Dump()const{
	cout<<m_x<<" "<<m_y<<" "<<m_z<<endl;
}

int Boundary<2>::GetMirorID()const{
	int x=m_x;
	int y=m_y;
	if(x<=0){
		y=-y;
		x=-x;
	}
	if(x==0){
		return 0;
	}
	switch(y){
		case -1:
		return 1;
		break;
		case 0:
		return 2;
		break;
		case 1:
		return 3;
		break;
	}
}

int Boundary<3>::GetMirorID()const{
	int x=m_x;
	int y=m_y;
	int z=m_z;
bool pos=false;
	if(x==1){
		pos=true;
	}
	else if(x==0){
		if(y==1){
			pos=true;
		}
		else if(y==0){
			if(z==1){
				pos=true;
			}
		}
		}
		if(!pos){
			x=-x;
			y=-y;
			z=-z;
		}
		
		if(x==0){
			
			if(y==0){
				return 0;
				}
				switch(y){
		case -1:
		return 1;
		break;
		case 0:
		return 2;
		break;
		case 1:
		return 3;
		break;
	}
		}
		else{
		switch(y){
			case -1:
			switch(z){
			case -1:
			return 4;
			break;
			case 0:
			 return 5;
			break;
			case 1:
			 return 6;
			break;
			}
			break;
			case 0:
			switch(z){
			case -1:
			return 7;
			break;
			case 0:
			 return 8;
			break;
			case 1:
			 return 9;
			break;
			}
			
			break;
			case 1:
			switch(z){
			case -1:
			return 10;
			break;
			case 0:
			 return 11;
			break;
			case 1:
			 return 12;
			break;
			}
			break;
		}	
		}
	
}

void Boundary<2>::Get(int &x,int &y)const{
	x=m_x;
	y=m_y;
}

void Boundary<3>::Get(int &x,int &y,int &z)const{
	x=m_x;
	y=m_y;
	z=m_z;
}