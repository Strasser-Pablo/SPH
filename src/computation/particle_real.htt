#include "particle.h"

#include "kernel.h"
#include "particles.h"
#include <iostream>

#include "pressure.h"
#include "voisin.h"
ParticleReal::ParticleReal():m_type(none),m_fixed(false),m_container(0)   ,m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(false),m_converged(true),m_b_0_done(false),m_nb_it(0),m_1_over_m(1),m_1_over_density_2(0),m_const_speed(false)
{
}

ParticleReal::ParticleReal(physvector< DIM > pos, ParticleType type,bool fixed):m_pos(pos),m_type(type),m_fixed(fixed),m_container(0)   ,m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(false),m_converged(true),m_b_0_done(false),m_nb_it(0),m_1_over_m(1),m_1_over_density_2(0),m_const_speed(false)
{
    m_m=1;
    m_density0=1000;
}

ParticleReal::ParticleReal(physvector< DIM > pos,physvector<DIM> speed ,ParticleType type,bool fixed):m_pos(pos),m_speed(speed),m_type(type),m_fixed(fixed),m_container(0) ,m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(false),m_converged(true),m_b_0_done(false),m_nb_it(0),m_1_over_m(1),m_1_over_density_2(0),m_const_speed(false)
{
	m_m=1;
    m_density0=1000;
}
bool ParticleReal::GetBoundary() const{
return m_boundary;
}

void ParticleReal::SetBoundary(bool b) {
 m_boundary=b;
 if(b){
	 cout<<"boundary set to true"<<endl;
 }
}

double ParticleReal::GetMass() const
{
    return m_m;
}




double ParticleReal::GetDensity() const
{
    return m_density;
}

double ParticleReal::GetMassDensity() const
{
    return m_m*m_density;
}

double ParticleReal::GetPressure() const
{
    return pressure(GetMassDensity(),water);
}

void ParticleReal::SetM(double m)
{
    m_m=m;
}



void ParticleReal::SetDensity(double rho)
{
    m_density=rho;
	m_1_over_density_2=1/pow(m_density,2);
}

double ParticleReal::Distance2(const Particle& A) const
{
    return m_pos.Distance2(A->m_pos);
}

double ParticleReal::Distance(const Particle& A) const
{
    return m_pos.Distance(A->m_pos);
}

void ParticleReal::SetPos(physvector< DIM > pos)
{
    m_pos=pos;
}

void ParticleReal::SetSpeed(physvector< DIM > speed)
{
    m_speed=speed;
}




physvector< DIM > ParticleReal::GetPos() const
{
    return m_pos;
}


void ParticleReal::ComputeDensity()
{
    double rho=0;
    for (Voisin::iterator it=m_voisin->begin();it!=m_voisin->end();++it) {
        rho+=Kernel_spline5(GetPos()-(*it)->GetPos(),h);
    }
    SetDensity(rho);
}

bool ParticleReal::Equal(const Particle part)const {
   return part->GetPos()==GetPos();
}

inline physvector<DIM> ParticleReal::GetSpeed() const {
    return m_speed;
}





bool ParticleReal::PreComputeMove(double dt) {
  if(!m_fixed){

m_speed+=Force()*dt/2;
m_pos+=m_speed*dt;
ComputeDensity();
double rap=(m_density0-m_density)/m_density0;
m_b=rap/2/m_density;
if(GetBoundary()){
	m_converged=true;
return false;	
}
m_p=0;
m_pv=0;
bool ret=abs(rap)>0.0001;
m_converged=!ret;

return ret;
  }

return false;
}

void ParticleReal::ComputeMove(double dt) {
  if(!m_fixed){
m_speed+=Force()*dt;
m_pos+=m_speed*dt;
}
}

void ParticleReal::Dump()const {
    cout<<"pos "<<m_pos<<" speed "<<m_speed<<endl;
}



//TODO: to rewrite
physvector<DIM> ParticleReal::ComputeSurface_Force()
{
physvector<DIM> temp;
/*
for(Particles::const_iterator it=m_voisin->begin_particles();it!=m_voisin->end_particles();++it){
 //temp+= Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h)*(m_surface_tens/pow(GetDensity(),2)+(*it)->m_surface_tens/pow((*it)->GetDensity(),2));
}
 */
return temp;
}
//Todo: To Rewrite
physvector< DIM > ParticleReal::ComputeSurface_Tensor_ind( ParticleType A, ParticleType B) const
{
physvector<DIM> grad=Color_Grad(A,B);
double d=grad.Norm();
physvector<DIM> I;
if(DIM==3){
 I=physvector< 3  >(1,1,1);
}
 physvector<DIM> ret;
if(d!=0){
//ret=surface_Const(A,B)/d*(1./DIM*pow(d,2)*I-grad*grad);
}
return ret;
}


physvector< DIM > ParticleReal::Color_Grad(ParticleType A,ParticleType B)const
{
  physvector<DIM> temp;
  if(m_type!=A){
   return temp;
  }
  if(A==B){
   return temp;
  }
/*
 Todo 
  for(Particles::const_iterator it=m_voisin.begin();it!=m_voisin.end();++it){
  if((*it)->m_type==B){
   temp+=1./pow((*it)->GetDensity(),2)*Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h);
  }
   
}
*/
#ifdef DOXYGEN
ParticleReal p;
p.GetDensity();
Kernel_grad_spline5(GetPos());
#endif //DOXYGEN

return temp*GetDensity();
}

void ParticleReal::ComputeSurface_Tensor()
{
if(m_type==water){
 m_surface_tens=ComputeSurface_Tensor_ind(m_type,Gaz);
}
else{
   m_surface_tens=ComputeSurface_Tensor_ind(m_type,water);
}

}


physvector<DIM> ParticleReal::Force()const{
//return ComputeSurface_Force()+G;
physvector<DIM> f;
f+=G;

for(Voisin::iterator it=m_voisin->begin();it!=m_voisin->end();++it){
	if(Equal(*it)){
		continue;
	}
double B=(m_1_over_density_2+(*it)->m_1_over_density_2)*Kernel_grad_spline5_dir(GetPos()-(*it)->GetPos(),h);
double A=m_1_over_m*B;
physvector<DIM> unit=(GetPos()-(*it)->GetPos())/(GetPos()-(*it)->GetPos()).Norm();
if(presure_eq_state){
f-=0.5*A*(pressure(GetDensity()*m_m,water)+pressure((*it)->GetDensity()*(*it)->m_m,water))*unit;
}
f+=0.001*A/Distance(*it)*((GetSpeed()-(*it)->GetSpeed()));
f+=0.5*GetDensity()*B*unit*m_sub_grid;
}



return f;
}

double ParticleReal::GetR() const{
return m_r;
}
 void ParticleReal::SetR(double val){
m_r=val;
 }

 double ParticleReal::GetZ() const{
return m_z;
 }
 void ParticleReal::SetZ(double val){
 m_z=val;
 }
  double ParticleReal::GetP1() const{
return m_p1;
 }
 void ParticleReal::SetP1(double val){
m_p1=val;
 }

 double ParticleReal::GetP() const{
return m_p;
 }
 void ParticleReal::SetP(double val){
m_p=val;
 }


  void ParticleReal::AddR(double val){
m_r+=val;
 }
 void ParticleReal::AddRprec(double val){
m_rprec+=val;
 }
 void ParticleReal::AddP1(double val){
m_p1+=val;
}
 void ParticleReal::AddP(double val){
m_p+=val;
}

 double ParticleReal::MultRZ() const{
return m_r*m_z;
}

 double ParticleReal::MultRZprec() const{
return m_rprec*m_zprec;
}

 double ParticleReal::GetRprec() const{
 return m_rprec;
 }
 void ParticleReal::SetRprec(double val){
 m_rprec=val;
 }

  double ParticleReal::GetZprec() const{
 return m_zprec;
 }
  void ParticleReal::SetZprec(double val){
m_zprec=val;
}

 void ParticleReal::UpdateRZ(){
m_rprec=m_r;
m_zprec=m_z;
m_r=0;
m_z=0;
}


 double ParticleReal::GetB() const{
return m_b;
}
 void ParticleReal::SetB(double val){
m_b=val;
}

void ParticleReal::GetVoisin( Voisin & voisin) const {
voisin=*m_voisin;
}

bool ParticleReal::OKR() const{
return abs(m_r)<0.0000001;
}


double ParticleReal::CalculateA(const Particle& B)const{
	double ret=0;
	if(Equal(B)){
for(Voisin::iterator it=m_voisin->begin();it!=m_voisin->end();++it){
ret+=CalculateABas(*it);
}
}else{
ret=-CalculateABas(B);
}
return ret;
}

double ParticleReal::CalculateABas(const Particle& B)const{
	if(Equal(B)){
	return 0;	
	}
physvector<DIM> r=GetPos()-B->GetPos();
double ret=(1/GetDensity()+1/B->GetDensity())*Kernel_grad_spline5(r,h)*r/r.Norm2()/(Distance(B)*(GetMass()*GetDensity()+B->GetMass()*B->GetDensity()));

if(isnan(ret)){
	//cout<<"PPPPPPPPPPPPRRRRRROB NAN"<<endl;
	ret=0;
}

return ret;
}

void ParticleReal::SetB_Speed() {
	m_px=m_p;
	physvector<DIM> temp;
	for(Voisin::iterator it=m_voisin->begin(); it!=m_voisin->end(); ++it) {
		if(!Equal(*it)) {
				physvector<DIM> r=GetPos()-(*it)->GetPos();
				temp-=1/(GetMass())*Kernel_grad_spline5(r,h)*(1/pow(GetDensity(),2)+1/pow((*it)->GetDensity(),2))*(GetMass()*GetDensity()*((*it)->GetP())+(*it)->GetMass()*(*it)->GetDensity()*(GetP()))/(GetMass()*GetDensity()+(*it)->GetMass()*(*it)->GetDensity());
		}
	}
	//if(!GetBoundary()){
	m_pos+=temp;
	//}
	double ret=0;
	double eta=Mat_Const(m_type).eta;
	for(Voisin::iterator it=m_voisin->begin(); it!=m_voisin->end(); ++it) {
		if(!Equal(*it)) {
				double eta2=Mat_Const((*it)->m_type).eta;
				physvector<DIM> r=GetPos()-(*it)->GetPos();
				double v=(GetSpeed()*eta+(*it)->GetSpeed()*eta2)/(eta+eta2)*r/r.Norm()/2;
				ret+=(1/pow(GetDensity(),2)+1/pow((*it)->GetDensity(),2))*Kernel_grad_spline5(r,h)*r/r.Norm()*v;
		}
	}
	m_b=ret;
	m_p=0;

}

void ParticleReal::PreparePosition(bool &b) {
	m_pv=m_p;
	physvector<DIM> temp;
	for(Voisin::iterator it=m_voisin->begin(); it!=m_voisin->end(); ++it) {
			physvector<DIM> r=GetPos()-(*it)->GetPos();
			temp-=1/(GetMass())*Kernel_grad_spline5(r,h)*(1/pow(GetDensity(),2)+1/pow((*it)->GetDensity(),2))*(GetMass()*GetDensity()*((*it)->GetP())+(*it)->GetMass()*(*it)->GetDensity()*(GetP()))/(GetMass()*GetDensity()+(*it)->GetMass()*(*it)->GetDensity());
		}
	ComputeDensity();
		//if(!GetBoundary()){
	m_speed+=temp;
		//}
	double rap=(m_density0-m_density)/m_density0;
	bool ret=abs(rap)>0.01;
	/*if(ret||GetIsInBoundaryRegion()){
		ret=abs(rap)>0.0002;
	}*/
	m_converged=!ret;
	
		m_p=0;
	b=b||ret;
	m_b=rap/2/m_density;
	
	
}

void ParticleReal::Calculate0Density(){
	if(m_b_0_done){
		return;
	}
	m_density0=m_density;
	m_m=1000/m_density0;
	m_1_over_m=1/m_m;
}

bool ParticleReal::GetIsInBoundaryRegion()const {
	return m_container->GetIsInBoundaryRegion();
}

void ParticleReal::WritePos(fstream &out)const{
	m_pos.WritePos(out);
}
//use m_force calculated in the calculus of time step.
 void ParticleReal::preComputeMove_predictor(double dt){
	   if(!m_fixed){
	 m_pos0=m_pos;
	 m_speed0=m_speed;
	 m_pos0_5=m_pos0;
	 m_speed0_5=m_speed0;
	 m_pos+=dt/2*m_speed;
	 m_speed+=dt/2*m_force;
	 m_nb_it=0;
	   }
 }
	 void ParticleReal::ComputeMove_predictor(double dt,bool &b){
		   if(!m_fixed){
		m_pos0_5=m_pos;
	 m_speed0_5=m_speed;
	  if(!m_const_speed){
	 m_speed=m_speed0+dt/2*Force();
	  }
	m_pos=m_pos0+dt/2*m_speed;
	bool ret=false;
	ret=ret||(m_pos-m_pos0_5).Norm2()/m_pos.Norm2()>0.0000000001;
	ret=ret||(m_speed-m_speed0_5).Norm2()/m_speed.Norm2()>0.0000000001;
	if(ret){
		++m_nb_it;
	}
	b=b||ret;
		   }
}

void ParticleReal::DoMove_predictor(){
	  if(!m_fixed){
	m_pos=2*m_pos-m_pos0;
	m_speed=2*m_speed-m_speed0;
	  }
}

 int ParticleReal::GetNb_It()const{
	 return m_nb_it;
 }
 
  void ParticleReal::NextForceTimeStep(double &dt)const{
	    if(!m_fixed&&!m_const_speed){
	  m_force=Force();
	double dttemp=sqrt(h/m_force.Norm());
	if(dttemp<dt){
		dt=dttemp;
	}
  }else if(m_const_speed){
	m_force=physvector<DIM>();  
  }
  }
  
   void ParticleReal::NextCourantVisciousTimeStep(double &dt) const{
	     if(!m_fixed){
	  double temp=0;
	  if(!m_const_speed){
	  for(Voisin::const_iterator it=m_voisin->begin(); it!=m_voisin->end(); ++it) {
		  if(Equal(*it)){
			  continue;
		  }
			double temp2=abs(h*(GetSpeed()-(*it)->GetSpeed())*(GetPos()-(*it)->GetPos())/(GetPos()-(*it)->GetPos()).Norm2());
			if(temp2>temp){
				temp=temp2;
			}
		  }
	temp=h/(sound_speed+temp);
	  }
	  else{
		  temp=h/sound_speed;
	  }
	if(dt>temp){
		dt=temp;
	}
  }
   }
   
   
    
void ParticleReal::SetConstSpeed(bool b){
		m_const_speed=b;
	}
  bool ParticleReal::GetConstSpeed(){
	 return m_const_speed;
 }
 
 void ParticleReal::CalculateSubGridTens(){
	 physvector<DIM> x;
	 physvector<DIM> y;
	 physvector<DIM> z;
	 double u0x;
	 double u0y;
	 double u0z;
	 GetSpeed().Get(u0x,u0y,u0z);
	 for(Voisin::iterator it=m_voisin->begin();it!=m_voisin->end();++it){
		 physvector<DIM> temp=0.5*(m_1_over_density_2+(*it)->m_1_over_density_2)*Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h);
	 double ux;
	 double uy;
	 double uz;
	 (*it)->GetSpeed().Get(ux,uy,uz);
	 x=temp*(ux+u0x);
	 y=temp*(uy+u0y);
	 z=temp*(uz+u0z);
 }
 m_sub_grid=GetDensity()*Tensor<3>(x,y,z);
 m_sub_grid.MakeSymetric();
 m_sub_grid*=2*pow(0.1*h,2)*sqrt(2)*m_sub_grid.Norm();
 }