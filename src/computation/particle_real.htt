#include "particle.h"

#include "kernel.h"
#include "particles.h"
#include <iostream>

#include "pressure.h"
ParticleReal::ParticleReal()
{

}

ParticleReal::ParticleReal(physvector< DIM > pos, ParticleType type, double m):m_pos(pos),m_type(type),m_m(m)
{
  
}

ParticleReal::ParticleReal(physvector< DIM > pos,physvector<DIM> speed ,ParticleType type, double m):m_pos(pos),m_speed(speed),m_type(type),m_m(m)
{

}


double ParticleReal::GetM() const
{
    return m_m;
}

double ParticleReal::GetP() const
{
    return m_p;
}


double ParticleReal::GetDensity() const
{
    return m_density;
}

void ParticleReal::SetM(double m)
{
    m_m=m;
}

void ParticleReal::SetP(double p)
{
    m_p=p;
}

void ParticleReal::SetDensity(double rho)
{
    m_density=rho;
}

double ParticleReal::Distance2(Particle& A)
{
    return m_pos.Distance2(A->m_pos);
}

void ParticleReal::SetPos(physvector< DIM > pos)
{
    m_pos=pos;
}

void ParticleReal::SetSpeed(physvector< DIM > speed)
{
    m_speed=speed;
}

void ParticleReal::SetAcceleration(physvector< DIM > force)
{
    m_a=force;
}

void ParticleReal::AddAcceleration(physvector< DIM > force)
{
    m_a+=force;
}

void ParticleReal::ResetAcceleration() {
    m_a=physvector< DIM>();
}
physvector< DIM > ParticleReal::GetPos() const
{
    return m_pos;
}

physvector< DIM > ParticleReal::GetAcceleration() const
{
    return m_a;
}

void ParticleReal::ComputePressure_Density(const Particles & FindVoisin)
{
    double rho=0;
    for (list<Particle>::const_iterator it=FindVoisin.begin();it!=FindVoisin.end();it++) {
        rho+=Kernel_spline5(GetPos()-(*it)->GetPos(),h);

    }
    SetDensity(rho);
//   SetP((rho-WaterConst.rho0)*WaterConst.k+3000);
    SetP(pressure(rho*GetM()));
}

bool ParticleReal::Equal(const Particle part)const {
    return this== part.Get();
}

inline physvector<DIM> ParticleReal::GetSpeed() const {
    return m_speed;
}



void ParticleReal::ComputeGravity_Force() {
    AddAcceleration(G);
}

void ParticleReal::ComputeMove(double dt) {
    m_pos+=dt*m_speed;
    m_speed+=dt*m_a;
    ResetAcceleration();
}

void ParticleReal::Dump() {
    cout<<"pos "<<m_pos<<" speed "<<m_speed<<endl;
}

template<class Archive>
void ParticleReal::serialize(Archive& ar, const unsigned int version)
{
    ar &BOOST_SERIALIZATION_NVP(m_pos);
    ar &BOOST_SERIALIZATION_NVP(m_speed);
    ar &BOOST_SERIALIZATION_NVP(m_density);
    ar &BOOST_SERIALIZATION_NVP(m_p);
    ar &BOOST_SERIALIZATION_NVP(m_type);
    ar &BOOST_SERIALIZATION_NVP(m_m);
}
void ParticleReal::ComputeInternal_Force(const Particles & FindVoisin) {
    physvector<DIM> ftot;
    double pact=GetP();
    physvector<DIM>  sact=GetSpeed();
    ParticleReal  real;
    for (list<Particle>::const_iterator it=FindVoisin.begin();it!=FindVoisin.end();it++) {
        if (!Equal(*it)) {
            real=*(*it);
            ftot-=1/GetM()*(GetP()/GetDensity()+real.GetP()/real.GetDensity())*Kernel_grad_spline5(GetPos()-real.GetPos(),h);
            ftot+=1/GetM()*Mat_Const(m_type).eta*(1/pow(GetDensity(),2)+1/pow(real.GetDensity(),2))/(GetPos()-real.GetPos()).Norm()*Kernel_grad_spline5(GetPos()-real.GetPos(),h)*(GetSpeed()-GetSpeed());
        }
    }

    AddAcceleration(ftot);
}
