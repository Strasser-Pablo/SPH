#include "particle.h"

#include "kernel.h"
#include "particles.h"
#include <iostream>

#include "pressure.h"
ParticleReal::ParticleReal():m_fixed(false),m_container(0),m_type(none),m_density0(0),m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(false)
{

}

ParticleReal::ParticleReal(physvector< DIM > pos, ParticleType type, double r,double rho_0,bool fixed,bool boundary):m_pos(pos),m_type(type),m_fixed(fixed),m_container(0)   ,m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(boundary)
{
    double V=4./3.*M_PI*pow(r,3);
    m_m=rho_0*V;
    m_density0=1/V;
}

ParticleReal::ParticleReal(physvector< DIM > pos,physvector<DIM> speed ,ParticleType type, double r,double rho_0,bool fixed,bool boundary):m_pos(pos),m_speed(speed),m_type(type),m_fixed(fixed),m_container(0) ,m_density(0),m_m(0),m_b(0),m_p(0),m_pv(0),m_px(0),m_p1(0),m_r(0),m_rprec(0),m_zprec(0),m_z(0),m_boundary(boundary)
{
       double V=4./3.*M_PI*pow(r,3);
    m_m=rho_0*V;
    m_density0=1/V;
}

bool ParticleReal::GetBoundary() const{
return m_boundary;	
}

double ParticleReal::GetM() const
{
    return m_m;
}




double ParticleReal::GetDensity() const
{
    return m_density;
}

void ParticleReal::SetM(double m)
{
    m_m=m;
}



void ParticleReal::SetDensity(double rho)
{
    m_density=rho;
}

double ParticleReal::Distance2(const Particle& A) const
{
    return m_pos.Distance2(A->m_pos);
}

double ParticleReal::Distance(const Particle& A) const
{
    return m_pos.Distance(A->m_pos);
}

void ParticleReal::SetPos(physvector< DIM > pos)
{
    m_pos=pos;
}

void ParticleReal::SetSpeed(physvector< DIM > speed)
{
    m_speed=speed;
}




physvector< DIM > ParticleReal::GetPos() const
{
    return m_pos;
}


void ParticleReal::ComputeDensity()
{
    double rho=0;
    UpdateVoisin();
    for (list<Particle>::const_iterator it=m_voisin.begin();it!=m_voisin.end();++it) {
        rho+=Kernel_spline5(GetPos()-(*it)->GetPos(),h);

    }

    SetDensity(rho);


}

bool ParticleReal::Equal(const Particle &part)const {
    return this== part.Get();
}

inline physvector<DIM> ParticleReal::GetSpeed() const {
    return m_speed;
}





bool ParticleReal::PreComputeMove(double dt) {
  if(!m_fixed){

m_speed+=Force()*dt/2;
m_pos+=m_speed*dt;
ComputeDensity();
double rap=(m_density0-m_density)/m_density0;
return abs(rap)>0.01;
}
return false;
}

void ParticleReal::Dump()const {
    cout<<"pos "<<m_pos<<" speed "<<m_speed<<endl;
}

template<class Archive>
void ParticleReal::serialize(Archive& ar, const unsigned int version)
{
    ar &BOOST_SERIALIZATION_NVP(m_pos);
    ar &BOOST_SERIALIZATION_NVP(m_speed);
    ar &BOOST_SERIALIZATION_NVP(m_density);
    ar &BOOST_SERIALIZATION_NVP(m_p);
    ar &BOOST_SERIALIZATION_NVP(m_type);
    ar &BOOST_SERIALIZATION_NVP(m_m);
    #ifdef DOXYGEN
    physvector<3> p;
    p.serialize(ar,0);
    #endif //DOXYGEN
}


//TODO: to rewrite
physvector<DIM> ParticleReal::ComputeSurface_Force()
{
physvector<DIM> temp;
for(Particles::const_iterator it=m_voisin.begin();it!=m_voisin.end();++it){
 //temp+= Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h)*(m_surface_tens/pow(GetDensity(),2)+(*it)->m_surface_tens/pow((*it)->GetDensity(),2));
}
return temp;
}
//Todo: To Rewrite
physvector< DIM > ParticleReal::ComputeSurface_Tensor_ind( ParticleType A, ParticleType B) const
{
physvector<DIM> grad=Color_Grad(A,B);
double d=grad.Norm();
physvector<DIM> I;
if(DIM==3){
 I=physvector< 3  >(1,1,1);
}
 physvector<DIM> ret;
if(d!=0){
//ret=surface_Const(A,B)/d*(1./DIM*pow(d,2)*I-grad*grad);
}

}


physvector< DIM > ParticleReal::Color_Grad(ParticleType A,ParticleType B)const
{
  physvector<DIM> temp;
  if(m_type!=A){
   return temp;
  }
  if(A==B){
   return temp;
  }
for(Particles::const_iterator it=m_voisin.begin();it!=m_voisin.end();++it){
  if((*it)->m_type==B){
   temp+=1./pow((*it)->GetDensity(),2)*Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h);
  }
}

#ifdef DOXYGEN
ParticleReal p;
p.GetDensity();
Kernel_grad_spline5(GetPos());
#endif //DOXYGEN

return temp*GetDensity();
}

void ParticleReal::ComputeSurface_Tensor()
{
if(m_type==water){
 m_surface_tens=ComputeSurface_Tensor_ind(m_type,Gaz);
}
else{
   m_surface_tens=ComputeSurface_Tensor_ind(m_type,water);
}

}


physvector<DIM> ParticleReal::Force()const{
//return ComputeSurface_Force()+G;
return G;
}

double ParticleReal::GetR() const{
return m_r;
}
 void ParticleReal::SetR(double val){
m_r=val;
 }

 double ParticleReal::GetZ() const{
return m_z;
 }
 void ParticleReal::SetZ(double val){
 m_z=val;
 }
  double ParticleReal::GetP1() const{
return m_p1;
 }
 void ParticleReal::SetP1(double val){
m_p1=val;
 }

 double ParticleReal::GetP() const{
return m_p;
 }
 void ParticleReal::SetP(double val){
m_p=val;
 }


  void ParticleReal::AddR(double val){
m_r+=val;
 }
 void ParticleReal::AddRprec(double val){
m_rprec+=val;
 }
 void ParticleReal::AddP1(double val){
m_p1+=val;
}
 void ParticleReal::AddP(double val){
m_p+=val;
}

 double ParticleReal::MultRZ() const{
return m_r*m_z;
}

 double ParticleReal::MultRZprec() const{
return m_rprec*m_zprec;
}

 double ParticleReal::GetRprec() const{
 return m_rprec;
 }
 void ParticleReal::SetRprec(double val){
 m_rprec=val;
 }

  double ParticleReal::GetZprec() const{
 return m_zprec;
 }
  void ParticleReal::SetZprec(double val){
m_zprec=val;
}

 void ParticleReal::UpdateRZ(){
m_rprec=m_r;
m_zprec=m_z;
}


 double ParticleReal::GetB() const{
return m_b;
}
 void ParticleReal::SetB(double val){
m_b=val;
}

void ParticleReal::GetVoisin( Particles & voisin) const {
voisin=m_voisin;
}

bool ParticleReal::OKR() const{
return m_r<0.001;
}


double ParticleReal::CalculateA(const Particle& B,Particles & voisin)const{
double ret=0;
if(Equal(B)){
for(Particles::iterator it=voisin.begin();it!=voisin.end();++it){
ret+=CalculateABas(*it);
}
}else{
ret=-CalculateABas(B);
}
return ret;
}

double ParticleReal::CalculateABas(const Particle& B)const{
physvector<DIM> r=GetPos()-B->GetPos();
return (1/GetDensity()+1/B->GetDensity())*Kernel_grad_spline5(r,h)*r/r.Norm2()/(Distance(B)*(GetM()*GetDensity()+B->GetM()*B->GetDensity()));
}

void ParticleReal::SetB_Speed() {
	physvector<DIM> temp;
	for(Particles::const_iterator it=m_voisin.begin(); it!=m_voisin.end(); ++it) {
		if(!Equal(*it)) {
			if(!GetBoundary()) {
				physvector<DIM> r=GetPos()-(*it)->GetPos();
				temp-=1/(GetM())*Kernel_grad_spline5(r,h)*(GetM()*GetDensity()*((*it)->GetP())+(*it)->GetM()*(*it)->GetDensity()*(GetP()))/(GetM()*GetDensity()+(*it)->GetM()*(*it)->GetDensity());
			}
		}
	}
	m_pos+=temp;
	double ret=0;
	double eta=Mat_Const(m_type).eta;
	for(Particles::const_iterator it=m_voisin.begin(); it!=m_voisin.end(); ++it) {
		if(!Equal(*it)) {
			if(!GetBoundary()) {
				double eta2=Mat_Const((*it)->m_type).eta;
				physvector<DIM> r=GetPos()-(*it)->GetPos();
				double v=(GetSpeed()*eta+(*it)->GetSpeed()*eta2)/(eta+eta2)*r/r.Norm()/2;
				ret+=(1/pow(GetDensity(),2)+1/pow((*it)->GetDensity(),2))*Kernel_grad_spline5(r,h)*r/r.Norm2()*v;
			}
		}
	}
	m_b=ret;

	m_p=0;
}

