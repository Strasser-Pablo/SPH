#include "particle.h"

#include "kernel.h"
#include "particles.h"
#include <iostream>

#include "pressure.h"
ParticleReal::ParticleReal():m_fixed(false),m_container(0)
{

}

ParticleReal::ParticleReal(physvector< DIM > pos, ParticleType type, double r,double rho_0,bool fixed):m_pos(pos),m_type(type),m_fixed(fixed),m_container(0)
{
    double V=4./3.*M_PI*pow(r,3);
    m_m=rho_0*V;
    m_density0=1/V;
}

ParticleReal::ParticleReal(physvector< DIM > pos,physvector<DIM> speed ,ParticleType type, double r,double rho_0,bool fixed):m_pos(pos),m_speed(speed),m_type(type),m_fixed(fixed),m_container(0)
{
       double V=4./3.*M_PI*pow(r,3);
    m_m=rho_0*V;
    m_density0=1/V;
}


double ParticleReal::GetM() const
{
    return m_m;
}

double ParticleReal::GetP() const
{
    return m_p;
}


double ParticleReal::GetDensity() const
{
    return m_density;
}

void ParticleReal::SetM(double m)
{
    m_m=m;
}

void ParticleReal::SetP(double p)
{
    m_p=p;
}

void ParticleReal::SetDensity(double rho)
{
    m_density=rho;
}

double ParticleReal::Distance2(Particle& A)
{
    return m_pos.Distance2(A->m_pos);
}

void ParticleReal::SetPos(physvector< DIM > pos)
{
    m_pos=pos;
}

void ParticleReal::SetSpeed(physvector< DIM > speed)
{
    m_speed=speed;
}




physvector< DIM > ParticleReal::GetPos() const
{
    return m_pos;
}


void ParticleReal::ComputeDensity()
{
    double rho=0;
    UpdateVoisin();
    for (list<Particle>::const_iterator it=m_voisin.begin();it!=m_voisin.end();it++) {
        rho+=Kernel_spline5(GetPos()-(*it)->GetPos(),h);

    }

    SetDensity(rho);


}

bool ParticleReal::Equal(const Particle part)const {
    return this== part.Get();
}

inline physvector<DIM> ParticleReal::GetSpeed() const {
    return m_speed;
}





bool ParticleReal::PreComputeMove(double dt) {
  if(!m_fixed){

m_speed+=Force()*dt/2;
m_pos+=m_speed*dt;
ComputeDensity();
double rap=(m_density0-m_density)/m_density0;
return abs(rap)>0.01;
}
return false;
}

void ParticleReal::Dump() {
    cout<<"pos "<<m_pos<<" speed "<<m_speed<<endl;
}

template<class Archive>
void ParticleReal::serialize(Archive& ar, const unsigned int version)
{
    ar &BOOST_SERIALIZATION_NVP(m_pos);
    ar &BOOST_SERIALIZATION_NVP(m_speed);
    ar &BOOST_SERIALIZATION_NVP(m_density);
    ar &BOOST_SERIALIZATION_NVP(m_p);
    ar &BOOST_SERIALIZATION_NVP(m_type);
    ar &BOOST_SERIALIZATION_NVP(m_m);
    #ifdef DOXYGEN
    physvector<3> p;
    p.serialize(ar,0);
    #endif //DOXYGEN
}



physvector<DIM> ParticleReal::ComputeSurface_Force()
{
physvector<DIM> temp;
for(Particles::const_iterator it=m_voisin.begin();it!=m_voisin.end();it++){
 temp+= Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h)*(m_surface_tens/pow(GetDensity(),2)+(*it)->m_surface_tens/pow((*it)->GetDensity(),2));
}
return temp;
}

physvector< DIM > ParticleReal::ComputeSurface_Tensor_ind( ParticleType A, ParticleType B) const
{
physvector<DIM> grad=Color_Grad(A,B);
double d=grad.Norm();
physvector<DIM> I;
if(DIM==3){
 I=physvector< 3  >(1,1,1);
}
 physvector<DIM> ret;
if(d!=0){
ret=surface_Const(A,B)/d*(1./DIM*pow(d,2)*I-grad*grad);
}

}


physvector< DIM > ParticleReal::Color_Grad(ParticleType A,ParticleType B)const
{
  physvector<DIM> temp;
  if(m_type!=A){
   return temp;
  }
  if(A==B){
   return temp;
  }
for(Particles::const_iterator it=m_voisin.begin();it!=m_voisin.end();it++){
  if((*it)->m_type==B){
   temp+=1./pow((*it)->GetDensity(),2)*Kernel_grad_spline5(GetPos()-(*it)->GetPos(),h);
  }
}

#ifdef DOXYGEN
ParticleReal p;
p.GetDensity();
Kernel_grad_spline5(GetPos());
#endif //DOXYGEN

return temp*GetDensity();
}

void ParticleReal::ComputeSurface_Tensor()
{
if(m_type==water){
 m_surface_tens=ComputeSurface_Tensor_ind(m_type,Gaz);
}
else{
   m_surface_tens=ComputeSurface_Tensor_ind(m_type,water);
}

}


physvector<DIM> ParticleReal::Force(){
//return ComputeSurface_Force()+G;
return G;
}
