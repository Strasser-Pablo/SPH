#include "particle.h"
#include "particles.h"
#include <list>
#include <algorithm>
#include "debug.h"
#include <fstream>
#include <string>
void Particles_List::Add(Particle part)
{
    Key<DIM> key=part->GetPos().ToKey(h);
    if (m_list.count(key)==0)
    {
        AddNeighbour(key);
    }

    m_list[key].Add(part);
	++m_n;
}


void Particles_List::AddNeighbour(Key< 3 > k)
{
    list<Key<DIM> > l=k.GetNeighbour();
	 list<Key<DIM> > l2;
    list<Particles*> n;

    Particles* pa0=&m_list[k];
	m_list[k].SetKey(k);
    for (list<Key<DIM> >::iterator it=l.begin(); it!=l.end(); ++it)
    {

        if (m_list.count(*it)>0)
        {
            //   cout<<"found"<<endl;
            //element found, add element in neighbour of the two element
            Particles*   pa=&m_list[*it];
            n.push_front(pa);
            list<Particles*>   templist=pa->GetNeighbour().GetParticlesVect();
			Boundaries<DIM> B=pa->GetBoundary();
			l2.push_back(pa->GetKey());
            //verify if element is in list if it's not add it
            if ( find(templist.begin(),templist.end(),pa0)==templist.end())
            {
                templist.push_back(pa0);
				Voisin V(templist);
                pa->SetNeighbour(V);
				Key<DIM> k1=pa->GetKey();
				B.AddBoundary(k1,k);
				pa->SetBoundary(B);
            }
        }
    }
	Voisin V(n);
    m_list[k].SetNeighbour(V);
	Boundaries<DIM> B(k,l2);
	m_list[k].SetBoundary(B);
}


void Particles_List::Update(list< Particle >::iterator& it, Particles* part)
{
    Key<DIM> key=(*it)->GetPos().ToKey(h);
    if (m_list.count(key)==0)
    {
        AddNeighbour(key);
    }
    Particles * pnew=&m_list[key];
	
    if(pnew!=part)
    { 
        pnew->splice(pnew->begin(),*part,it);
		(*it)->SetContainerParticles(pnew);
    }
}

void Particles_List::RemoveParticles(const Particles* part){
	Voisin v;
 part->GetNeighbour(v);
 list<Particles*> l=v.GetParticlesVect();
for(list<Particles*>::iterator it=l.begin();it!=l.end();it++){
	(*it)->RemoveParticlesNeighbour(part);
}
m_list.erase(part->GetKey());
}


void Particles_List::write(double dt  ) const
{
static int filenum=0;
char filename[13];
sprintf(filename,"out%05d.vtu",filenum);
fstream out (filename, fstream::out);
out<<"<?xml version=\"1.0\"?>"<<endl;
out<<"<VTKFile type= \"UnstructuredGrid\"  version= \"0.1\"  byte_order= \"BigEndian\">"<<endl;                      
out<<"<UnstructuredGrid>"<<endl;
out<<"<Piece NumberOfPoints=\""<<m_n<<"\" NumberOfCells=\""<<m_n<<"\">"<<endl; 
out<<"<Points>"<<endl;                                                                                         
out<<"<DataArray type=\"Float64\" NumberOfComponents=\""<<DIM<< "\" format=\"ascii\">"<<endl;
 for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.WritePos(out);
    }
out<<"</DataArray>"<<endl;
out<<"</Points>"<<endl;
out<<"<Cells>"<<endl;
out<<"<DataArray type=\"Int32\" Name=\"connectivity\" format=\"ascii\">"<<endl;
for(int i=0;i<m_n;i++){
	out<<i<<endl;
}
out<<"</DataArray>"<<endl;
out<<"<DataArray type=\"Int32\" Name=\"offsets\" format=\"ascii\">"<<endl;
for(int i=1;i<=m_n;i++){
	out<<i<<endl;
}
out<<"</DataArray>"<<endl;
out<<"<DataArray type=\"Int32\" Name=\"types\" format=\"ascii\">"<<endl;
for(int i=0;i<m_n;i++){
	out<<1<<endl;
}
out<<"</DataArray>"<<endl;
out<<"</Cells>"<<endl;
out<< "<PointData Scalars=\"Density\">"<<endl;                                                
out<< "<DataArray type=\"Float64\" Name=\"Density\" format=\"ascii\">"<<endl;
 for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.Density(out);
    }
out<< "</DataArray>"<<endl;
out<< "<DataArray type=\"Float64\" Name=\"Pressures\" format=\"ascii\">"<<endl;
for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.Pressures(out);
    }
out<< "</DataArray>"<<endl;
out<< "<DataArray type=\"Float64\" Name=\"Mass\" format=\"ascii\">"<<endl;
for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.Mass(out);
    }
out<< "</DataArray>"<<endl;
out<< "<DataArray type=\"Float64\" Name=\"Mass Density\" format=\"ascii\">"<<endl;
for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.MassDensity(out);
    }
out<< "</DataArray>"<<endl;

out<< "<DataArray type=\"Int32\" Name=\"NB_it\" format=\"ascii\">"<<endl;
for (map<Key<DIM> ,Particles>::const_iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.NB_it(out);
    }
out<< "</DataArray>"<<endl;

out<< "</PointData>"<<endl; 
out<<"</Piece>"<<endl;
out<<"</UnstructuredGrid>"<<endl;
out<<"</VTKFile>"<<endl;
out.close();
static fstream outtot ("animation.pvd", std::fstream::binary |std::fstream::out);
if(filenum==0){
outtot<<"<VTKFile type=\"Collection\" version=\"0.1\" byte_order=\"LittleEndian\">"<<endl;
 outtot<<" <Collection>"<<endl;
}
 outtot<<" <DataSet timestep=\""<<m_t<<"\" group=\"\" part=\"0\" file=\""<<filename<<"\"/>"<<endl;
 streampos pos;
   pos=outtot.tellp();
   outtot<<"</Collection>"<<endl;
outtot<<"</VTKFile>"<<endl;
outtot.seekp(pos);
cout<<"file num "<<filenum<<" nb part "<<m_n<<" time "<<m_t<<" dt "<<dt<<endl;
++filenum;
}

   void Particles_List::DumpBoundary()const {
	    for(map< Key<DIM>, Particles >::const_iterator it=m_list.begin(); it!=m_list.end(); it++)
    {
		cout<<"Key"<<endl;
        it->second.GetKey().Dump();
		cout<<"Boundary"<<endl;
		it->second.GetBoundary().Dump();
    }
   }

void Particles_List::CorrectDensity(){
		FindBoundary();
bool bcont=true;
int i=0;
while(bcont){
    bcont=false;
ConjugateGradiant();
SetB_Speed();
//ConjugateGradiant();
PreparePosition(bcont);
i++;
 }
 cout<<"correction iteration "<<i<<endl;
}


void Particles_List::Compute(double &dt)
{
    for (map<Key<DIM> ,Particles>::iterator it=m_list.begin();it!=m_list.end();++it) {
		it->second.ComputeDensity();
    }
	  for (map<Key<DIM> ,Particles>::iterator it=m_list.begin();it!=m_list.end();++it) {
		it->second.CalculateSubGridTens();
    }
	  dt=NextTimeStep();
     bool ret=false;
	 if(presure_laplacien){
    for (map<Key<DIM> ,Particles>::iterator it=m_list.begin();it!=m_list.end();++it) {
        ret=it->second.PreComputeMove(dt)||ret;
    }
	if(ret){
	CorrectDensity();	
	}
	 }
	if(presure_eq_state){
		//euler
		/*
	  for (map<Key<DIM> ,Particles>::iterator it=m_list.begin();it!=m_list.end();++it) {
        it->second.ComputeMove(DT);
    }
	 */
	 //predictor corrector
	 predictor_corrector_compute(dt);
	}
    m_t+=dt;
   map<Key<DIM> ,Particles>::iterator it=m_list.begin();
   while(it!=m_list.end()){
	   map<Key<DIM> ,Particles>::iterator it2=it;
	   ++it;
        it2->second.Update(this);
    }
    #if DOXYGEN
    ParticleReal p;
    p.ComputePressure_Density();
    p.ComputeSurface_Tensor();
    p.ComputeInternal_Force();
    p.ComputeInternal_Force();
    p.ComputeGravity_Force();
    p.ComputeMove(DT);
    p.Update(this);
    #endif //DOXYGEN
}

double Particles_List::GetTime()const{
	return m_t;
}